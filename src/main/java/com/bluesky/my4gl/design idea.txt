按照smalltalk的思路。
一切都是对象，类也是对象。最原始的对象是Object,Class。
然后一切都是消息。包括Class.new Variable.assign(var2), variable.compare(var2)
我觉得这样能简化一些事情，一切都能用对象和消息来描述，不挺好吗？
原本的赋值，创建，调用，都统一成了调用。
关于先有对象还是先有类的问题，我打算决定先有类。但也也是一个对象，相互递归定义。
在虚拟机里，首先Object,Class肯定是作为最基础的对象和类。
一般Object有其类来创建，但Class这个对象不同，它是系统初始化的时候由系统创建的，单实例。


系统一定有内部类，原始类。然后其他的类可以动态加载，从磁盘或者网络。当代码里需要有用到某个类的时候，加载它。
比如：Foo.new //创建一个Foo类的对象
然而Foo作为类的同时，也是一个对象，所以它能处理new消息。new函数的定义在哪里呢？在它的类里面。
Foo类这个对象的类是什么呢？假设它叫X，那么，
class X {

  public Object new(){
    //这里创建对象。
  }
  
}
这个类同时也是对象的玩意，是为了支持反射。
这个X类则不再是对象了，它仅仅是一个类，它只能由系统创建，而不能通过其类（类为空）的new方法创建。


声明变量也可以理解为消息专递，或者认为是创建了一个Variable类的对象
Integer i;
Variable.new("i")

或者每个对象创建的时候，都赋予一个id或者名字。以便后面引用的时候表达。
比如： i -> Integer.new(7);


既然一切都是消息和对象，如果把传递消息理解为沟通，或者说话，那么到底谁在做事呢？是native实现的类的对象。
所以，在my4gl里，所有的普通对象都是不干事的领导，只有native实现的类的对象，才是是真正干活的。
所谓的干活就是数学计算和布尔运算和内存操作。还有IO。io类肯定是native的，并且接受的参数一般也是native的。



Foo,HelloWorld这样的类，作为类的时候是很平常的。但作为对象的时候，它们的类是X，或者ClassOfClass，
X具有一方法new。它们是由系统创建的实例。


